Сортировки:

a[i].compareTo(a[j]); //сравнивает два элемента, выдает числовое значение

лучшая скорость сортировки сравнениями O(n*log n)
log n появляется, потому что мы делим массив на два n раз

!!! O(n!)~O(n^n) почитать, так ли это !!!

Виды сортировки:
- пузырек
    - buble sort
    - shaker sort
- метод простых вставок (текущий элемент проверяется со всеми предыдущими до тех пор пока не встанет на свое место)
    (не нужны оптимизации как у пузырька + лучше скорость работы)
    - simple insert
    - binary insert
- сортировка слиянием (merge sort)
- быстрая сортировка (quick sort)
- сортировка Shell'a (Shell sort)
    (почти не используется, легче использовать простые сортировки)
- пирамидальная сортировка (heap sort)
    (почти не используется, потому что постоянно проигрывает)


Как можно оптимизировать квадратичную сортировку пузырьком:

- самый максимальный элемент кидать в конец и забывать о нем
- проверять, не отсортировался ли массив досрочно
- для того, чтобы быстро избавляться от минимальных элементов можно использовать
    shaker sorting(меняется направление проверки /* еще увеличивается время работы и сложность реализации */)

Как можно оптимизировать метод вставки:
- сделать двоичную вставку
    (искать место для элемента бин. поиском
        не всегда используют, потому что может быть большое кол-во перестановок
        + он сложнее
        т.е. использовать его только когда у нас легко сравниваются объекты)

Фоннейман предложил свою сортирвку(сортировка Von Neumana или сортировка слиянием(merge sort))
    Метод слияния(рекурсивный метод):
        1) есть два упорядоченных массива
        2) сравниваем два первых элемента этих массивов
            - массив с минимальныи первым элементом становится в начало
    Сложность определяется как Т(n):
        T(n) = 2 * T(n/2) + n
        T(n) ~ C * n * log2 n
    Недостаток главный: нужно много памяти для слияния

Быстрая сортировка:
    Используется в комбинации с каким-то алгоритмом
    Скорость в среднем лучшую скорость, но может и достигать скорости n*n
    Зависит от взятого элемента
        (обычно берут рандомный элемент)
        (крутой способ, берут 5 элементов и сравнивают их, выбирают средний элемент)
    Алгоритм:
        1) выбирается опорный элемент, остальные распихиваются на два массива(меньшие этого элемента и больше)
        2) осовобождаем этот элемент
        3) идем с конца, пока  не встретим элемент меньше того
        4) освобождаем этот элемент и просматриваем сверху больший элемент
        5) область просмотра сужается до одного свободно места, и вставляем туда свободный элемент оставшийся
        6) затем проделываем все это для двух массивов( > и < )
    Тогда скорость T(n) = n + 2 * T(n/2)
    T(n) ~ n log n
