Эти классы связаны между собой (Сверу вниз):
- `Functor`
- `Applicative`
- `Monad`

_Functor:_
	- fmap f _
	- <$> = flip fmap
		Можно применять функции по порядку
		` _ <$> f <$> g <$> h`
		_Пример:_
		Писали так:
		```haskell
		case something of
			Just k -> Just $ f k
			Nothing -> Nothing
		``` 
		Заменить можно на:
		```haskell
		something <$> f
		```
_Applicative:_
	`pure` в `Functor` нет, потому что не требуется поднимать функцию на уровень структуры
	`[sin, cos] <*> [3,5,8]`
	Полезен когда f от нескольких аргументов:
	`pure f <*> [3, 5, 8] <*> [1,5]`
	Иначе можно просто `Functor` использовать
	_Пример1:_
		`pure (+) <*> [1,2] <*> [10,20]`
		Применяется попарно каждый к каждому
	_Пример2:_
		`pure (+) <*> [] <*> [10,20]`
		Применяя к пустому списку получаем пустой список `[]`
	_Пример3:_
		`pure (+) <*> Nothing <*> Just 30`
		Результат Nothing
	`liftA2 f [3,5] [1,2]` из пакета `Control` вызывается
	Поднимает функцию
	Пример:
	`Control.Applicative.liftA2 (+) (Just 20) (Just 30)` результат `Just 50`
_Monad:_
	- `return :: a -> m a` - аналог `pure`
		В контракте написано, что `return = pure`
	- `(>>=) :: m a -> (a -> m b) -> m b` - связывание
		_Суть:_ извлекаем из структуры, а потом снова её туда помещаем
		_Пример1:_
		`Just 25 >>= (\n -> Just (n+1))` результат `Just 26`
		_Пример2:_
		Школьная задачка: Посчитать выражение
		`20+30-10+15` - такое допустимо, т.к. в результате вычисления не получается в промежуточных вычислениях числа `<0` или `>100`
		`20+5-30+10` - неправильное выражение
		Можно было бы считать, как:
		`20 <$> (+30) <$> (negate 10) <$> (+15)`
		Но хочется, чтобы была проверка на правильность выражения:
		`myFunc f x = if x < 0 || x >= 100 then Nothing else Just (f x)`
		Тогда записываем, как:
		`20 >>= myFunc (+30) >>= myFunc (negative 10)`
	- `fail :: String -> m a` - для вывода ошибки
		В отличии от `error` можно `fail` переопределить

---

```haskell
-- Открывем доступ только выставленные конструкторы и функции
module MyTree(BTree(Empty), ...) where -- Будет доступен только конструктор Empty
	data BTree a = Empty | Root ...

...
```
Ввод-вывод не входят в функциональную парадигму программирования
В haskell для этого есть `Monad IO`

_Пример:_ Прочесть строку, приписать `!`, вывести
`readLn :: Read a => IO a` - функция, которая считывает и возвращает монаду IO
Особая функция, которая не вписывается в фун. парадигму
Поэтому это не константа, а считывание
Тогда `readLn >>= (\s -> s ++ "!")`
`putStrLn :: String -> IO ()` - выводит
Тогда можно применить: `readLn >>= (\s -> putStrLn (s ++ "!"))`
Выдает ошибку: `*** Exception: user error (Prelude.readIO: no parse)`, нужно явно указать тип (ему лень с этим возиться, нужно самому попробовать)

Такой ввод вывод писать неудобно
Введем специальный синтаксис для такого
```haskell
do{
	s <- readLn -- Временно можно извлечь из под монады (важно это потом заключить в монаду)
	putStrLn (s ++ "!")
}
```
Это удобнее, когда много временных значений, чтобы не указывать много лямбд
```haskell
do{
	x <- readLn
	y <- readLn
	putStrLn (x ++ y)
}
```
Так можно делать для любой монады:
```haskell
do{
	x <- [1..5] 
	y <- [1..2]
	return (x + y) -- Получатся всевозможные суммы [2,3,3,4,4,5,5,6,6,7]
}
```
Но это можно заменить на `[ x+y | x <- [1..5], y <- [1..2] ]` через генератор списков
В отличие от `do` в генераторе можно записывать условия `[ x+y | x <- [1..5], y <- [1..2], x > 3 ]`
Хотя есть функция `guard :: Monad m => Bool -> m ()` - если `Bool = False` - выдает пустое значение
Тогда можно генератор заменить так:
```haskell
do{
	x <- [1..5] 
	y <- [1..2]
	guard (x > 3)
	return (x + y) -- Получатся всевозможные суммы [2,3,3,4,4,5,5,6,6,7]
}
```