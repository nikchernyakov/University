Эти классы связаны между собой (Сверу вниз):
- `Functor`
- `Applicative`
- `Monad`

## Functor: ##  
- fmap f _  
- <$> = flip fmap  
	Можно применять- функции по порядку  
	` _ <$> f <$> g <$> h`  

## Пример: ## 
	Писали так:  
	```haskell
	case something of
		Just k -> Just $ f k
		Nothing -> Nothing
	``` 
	Заменить можно на:  
	```haskell
	something <$> f
	```

## Applicative: ##  

`pure` в `Functor` нет, потому что не требуется поднимать функцию на уровень структуры  
`[sin, cos] <*> [3,5,8]`  
Полезен когда f от нескольких аргументов:  
`pure f <*> [3, 5, 8] <*> [1,5]`  
Иначе можно просто `Functor` использовать  

### Пример1: ###  
	`pure (+) <*> [1,2] <*> [10,20]`  
	Применяется попарно каждый к каждому  

### Пример2: ###  
	`pure (+) <*> [] <*> [10,20]`  
	Применяя к пустому списку получаем пустой список `[]`  

### Пример3: ###  
	`pure (+) <*> Nothing <*> Just 30`  
	Результат Nothing  

`liftA2 f [3,5] [1,2]` из пакета `Control` вызывается  
Поднимает функцию  
### Пример4:  ###
	`Control.Applicative.liftA2 (+) (Just 20) (Just 30)` результат `Just 50`  

## Monad: ##
- `return :: a -> m a` - аналог `pure`  
	В контракте написано, что `return = pure`  

- `(>>=) :: m a -> (a -> m b) -> m b` - связывание  
	__Суть:__ извлекаем из структуры, а потом снова её туда помещаем  

### Пример1: ###  
	`Just 25 >>= (\n -> Just (n+1))` результат `Just 26`  

### Пример2: ###  
	Школьная задачка: Посчитать выражение  
	`20+30-10+15` - такое допустимо, т.к. в результате вычисления не получается в промежуточных вычислениях числа `<0` или `>100`  
	`20+5-30+10` - неправильное выражение  
	Можно было бы считать, как:  
	`20 <$> (+30) <$> (negate 10) <$> (+15)`  
	Но хочется, чтобы была проверка на правильность выражения:  
	`myFunc f x = if x < 0 || x >= 100 then Nothing else Just (f x)`  
	Тогда записываем, как:  
	`20 >>= myFunc (+30) >>= myFunc (negative 10)`  

- `fail :: String -> m a` - для вывода ошибки  
	В отличии от `error` можно `fail` переопределить  

---

```haskell
-- Открывем доступ только выставленные конструкторы и функции
module MyTree(BTree(Empty), ...) where -- Будет доступен только конструктор Empty
	data BTree a = Empty | Root ...
...
```

---

Ввод-вывод не входят в функциональную парадигму программирования  
В haskell для этого есть `Monad IO`  

### Пример: ### Прочесть строку, приписать `!`, вывести  
	`readLn :: Read a => IO a` - функция, которая считывает и возвращает монаду IO  
	Особая функция, которая не вписывается в фун. парадигму  
	Поэтому это не константа, а считывание  
	Тогда `readLn >>= (\s -> s ++ "!")`  
	`putStrLn :: String -> IO ()` - выводит  
	Тогда можно применить: `readLn >>= (\s -> putStrLn (s ++ "!"))`  
	Выдает ошибку: `*** Exception: user error (Prelude.readIO: no parse)`, нужно явно указать тип (ему лень с этим возиться, нужно самому попробовать)  

Такой ввод вывод писать неудобно  
Введем специальный синтаксис для такого  
```haskell
do{
	s <- readLn -- Временно можно извлечь из под монады (важно это потом заключить в монаду)
	putStrLn (s ++ "!")
}
```
Это удобнее, когда много временных значений, чтобы не указывать много лямбд  
```haskell
do{
	x <- readLn
	y <- readLn
	putStrLn (x ++ y)
}
```
Так можно делать для любой монады:  
```haskell
do{
	x <- [1..5] 
	y <- [1..2]
	return (x + y) -- Получатся всевозможные суммы [2,3,3,4,4,5,5,6,6,7]
}
```

Но это можно заменить на `[ x+y | x <- [1..5], y <- [1..2] ]` через генератор списков  
В отличие от `do` в генераторе можно записывать условия `[ x+y | x <- [1..5], y <- [1..2], x > 3 ]`  
Хотя есть функция `guard :: Monad m => Bool -> m ()` - если `Bool = False` - выдает пустое значение  
Тогда можно генератор заменить так:  

```haskell
do{
	x <- [1..5] 
	y <- [1..2]
	guard (x > 3)
	return (x + y) -- Получатся всевозможные суммы [2,3,3,4,4,5,5,6,6,7]
}
```