-- Черняков Никита А3201
-- Домашняя работа 4
-- Условие:
-- Написать функцию preHigher :: Ord a => [a] -> [Int],
-- которая по заданному списку элементов выдает список индексов тех из них,
-- которые строго меньше следующего. Например, в числовом списке [1, 2.2, 2.1, 3.14, 2.7, 1.618] числа,
-- меньшие следующего в списке - это 1 и 2.1, поэтому вызов preHigher [1, 2.2, 2.1, 3.14, 2.7, 1.618]
-- должен выдать список [0, 2] - список индексов этих элементов.

module Homework where
import Data.List

-- preHigher :
-- 1) Объединяю list c (tail list) (т.е. сдвигаю на один элемент list вправо) в пару с помощью zip
-- Тогда получается вид пары примерно такой: (a1,a2)
-- 2) Использую функцию findIdices :: (a -> Bool) -> [a] -> [Int] (из Data.List)
-- Она выдает индексы тех элементов списка, которые удовлетворяют(True) функции (a -> Bool)
--   2.1) В качестве функции (a -> Bool) передаю (\(x,y) -> x < y)
--        Т.е. функция будет проверять, чтобы первый элемент пары(текущий элемент в списке) был строго меньше второго элемента(следующий в списке)
--   2.2) В качестве [a] передаю то, что получилось в пункте 1

preHigher :: Ord a => [a] -> [Int]
preHigher list = findIndices (\(x,y) -> x < y) $ zip list (tail list)

main = [
    preHigher [1, 2.2, 2.1, 3.14, 2.7, 1.618] == [0, 2],
    preHigher ['a', 'b', 'c'] == [0, 1],
    preHigher [1.1, 1.2, 2.2, 3, 1, 0.5] == [0, 1, 2],
    preHigher [] == [],   -- Этот странный тест почему-то делает ошибку компиляции,
    -- хотя, если попробовать вбить его отдельно, то все отлично работает...
    -- поясните пожалуйста по этому тесту, если не сложно, может я просто где-то ошибаюсь
    preHigher "ilovehaskel" == [0,1,2,4,6,9]
    ]
